import { themes, Steps } from "mdx-deck";
import Layout from "./components/Layout";
import Split from "./components/Split";
import { ImageLink } from "./components/ImageLink";
import { CodeSurfer } from "code-surfer";
import { nightOwl } from "@code-surfer/themes";
import { vsDark } from "@code-surfer/themes";
import { Counter } from "./components/After";
import { IntervalRefExample } from "./components/IntervalRef";
import { TitleEffect } from "./components/TitleEffect";
import { LayoutEffect, UseLayoutEffect } from "./components/LayoutEffect";
import { UsingContext } from "./components/UsingContext";
import { NotesApp } from "./components/NotesApp";
import { FancyInputExample } from "./components/fancy-input/FancyInputExample";
import { data as memoData, SearchResults } from "./components/SearchResults";
import { Heading } from "./components/Heading";
import { Quote } from "./components/Quote";
import { Grid } from "./components/Grid";
import { Overlay } from "./components/Overlay";
import { UnOrderedList, ListItem } from "./components/ListItems";
import { Tag } from "./components/Tag";
import { AnchorLink } from "./components/AnchorLink";
import { CodeSandbox } from "./components/CodeSandbox";
import { themeStyles } from "./theme";

export const theme = {
  ...themes.future,
  ...themes.prism,
  ...nightOwl,
};

<Layout>
  <Split>
    <Split>
      <ImageLink
        shape='round'
        src='https://raw.githubusercontent.com/bansalrachita/react-hooks-slides/fe2daa3af58e856a8c3433abf79412c62cfbf622/src/images/react-logo.svg'
        width='100px'
        height='100px'
        alt='React hooks logo'
      />
      <Heading>Introduction</Heading>
      <Heading>to React hooks</Heading>
    </Split>
  </Split>
  <Steps>
    <ImageLink
      margin='60px 0 0 50px'
      shape='round'
      src='https://github.com/bansalrachita/react-hooks-slides/blob/master/src/images/hook.gif?raw=true'
      width='300px'
      height='300px'
      alt='Gif of Captain Hook'
    />
  </Steps>
</Layout>

---

<Heading> What is React? </Heading>

<Quote>
  "Declarative, efficient and flexible JavaScript library for building user
  interfaces. It lets you compose complex UIs from smaller and isolated pieces
  of code called components"
</Quote>

<AnchorLink size='medium' href='https://reactjs.org/'>
  - https://reactjs.org/
</AnchorLink>

---

<CodeSurfer theme={themeStyles}>

```js title="Component"
import React from "react";

function MyComponent (props) => {

  return <div>Hello World!</div>;
}

```

</CodeSurfer>

<Overlay columns={2}>
  <ImageLink
    src='https://github.com/bansalrachita/react-hooks-slides/blob/master/src/images/hello-world.png?raw=true'
    width='400px'
    height='300px'
    alt='Hello World demo'
  />
</Overlay>

---

<Grid columns={1}>
  <Steps>
    <Tag>Update State</Tag>
    <Tag>Side Effects</Tag>
    <Tag>Access DOM Elements</Tag>
  </Steps>
</Grid>

---

<CodeSurfer>

```jsx title="React < 16.8"
class Counter extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      count: 0,
    };
  }

  increment = () => {
    const { count } = this.state;
    this.setState({ count: count + 1 });
  };

  render() {
    const { count } = this.state;

    return (
      <>
        <div>{`Count: ${count}`}</div>
        <button onClick={this.increment}>+</button>
      </>
    );
  }
}

export default Counter;
```

```jsx title="React < 16.8" 4:7,15:24
class Counter extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      count: 0,
    };
  }

  increment = () => {
    const { count } = this.state;
    this.setState({ count: count + 1 });
  };

  render() {
    const { count } = this.state;

    return (
      <>
        <div>{`Count: ${count}`}</div>
        <button onClick={this.increment}>+</button>
      </>
    );
  }
}

export default Counter;
```

```jsx title="React < 16.8" 10:13,21
class Counter extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      count: 0,
    };
  }

  increment = () => {
    const { count } = this.state;
    this.setState({ count: count + 1 });
  };

  render() {
    const { count } = this.state;

    return (
      <>
        <div>{`Count: ${count}`}</div>
        <button onClick={this.increment}>+</button>
      </>
    );
  }
}

export default Counter;
```

```jsx title="React < 16.8"
class Counter extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      count: 0,
    };
  }

  increment = () => {
    const { count } = this.state;
    this.setState({ count: count + 1 });
  };

  render() {
    const { count } = this.state;

    return (
      <>
        <div>{`Count: ${count}`}</div>
        <button onClick={this.increment}>+</button>
      </>
    );
  }
}

export default Counter;
```

</CodeSurfer>
<Overlay columns={2}>
  <ImageLink
    src="https://github.com/bansalrachita/react-hooks-slides/blob/master/src/images/counter-before.gif?raw=true"
    width="350px"
    height="300px"
    alt="Counter App Demo"
  />
</Overlay>

---

<CodeSurfer>

```js title="Function component" 2:4,7,10,15,16
import React, { useState } from "react";

export const Counter = () => {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  return (
    <>
      <div>{`Count: ${count}`}</div>
      <button onClick={increment}>+</button>
    </>
  );
};
```

```js title="Function component" 10:15
import React, { useState } from "react";

export const Counter = () => {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  return (
    <>
      <div>{`Count: ${count}`}</div>
      <button onClick={increment}>+</button>
    </>
  );
};
```

</CodeSurfer>

---

<Heading> React hooks </Heading>
<Grid columns={2}>
  <Steps>
    <p>
      <code>useCake()</code>
    </p>
    <p>
      <code>useFrosting()</code>
    </p>
    <p>
      <code>useBake()</code>
    </p>
    <p>
      <code>usePastries()</code>
    </p>
  </Steps>
</Grid>

---

<UnOrderedList>
  <ListItem>Use functions instead of classes.</ListItem>
  <ListItem>Simpler to write than classes due to less template code.</ListItem>
  <ListItem>
    Sharable state logic and complex state logic can be broken down into
    multiple such hooks.
  </ListItem>
  <ListItem>No render function and lifecycle methods.</ListItem>
</UnOrderedList>

---

<Heading>Rules of hooks</Heading>
<UnOrderedList>
  <ListItem>
    Only call hooks at the top level, don't call them inside loops, lists or
    nested functions.
  </ListItem>
  <ListItem>
    Only call Hooks from react function components or inside custom hooks.
  </ListItem>
</UnOrderedList>

<Notes>
  - Only Call Hooks at the Top Level Don't call hooks inside of loops, nested
  functions or inside conditions. This ensures that hooks are always called in
  the same order in successive component renders. The way this works is React
  stores the sequence of hooks call during the first render and keeps checking
  against the order hooks are called in subsequent renders of the component. -
  Only Call Hooks from React Functions.Ensure that state logic is available to
  components source code.
</Notes>

---

<CodeSurfer>

```jsx title="Examples"
export const Example = ({ data }) => {
  // ❌ Error
  if (!data) {
    useEffect(() => {
      useHook();
    });
  }

  return <UI />;
};
```

```js 1:6
export const Example = ({ data }) => {
  // ❌ Error
  onClick = () => useHook();

  return <UI />;
};
```

```js 1:6
export const Example = ({ data }) => {
  // 🟢 success
  useHook();

  return <UI />;
};
```

```js 1:6
export const useDom = () => {
  // 🟢 success
  useEffect(() => {
    document.title = "React is awesome 😊";
  });
};
```

</CodeSurfer>

---

<Heading> Built-in hooks</Heading>

<ImageLink
  src='https://github.com/bansalrachita/react-hooks-slides/blob/master/src/images/hooks_api.png?raw=true'
  width='500px'
  height='650px'
  altText='list of built-in hooks'
/>

---

<Heading>useState</Heading>

```js
const [state, setState] = useState(initialState);
```

<UnOrderedList>
  <ListItem>Returns a stateful value and a function to replace it.</ListItem>
  <ListItem>Takes in initial state as an argument.</ListItem>
  <ListItem>
    The <i>setState</i> updates the state and rerenders the component with the
    new value.
  </ListItem>
  <ListItem>
    Unlike <i>this.setState</i> in class components <i>useState</i> doesn't
    merge objects.
  </ListItem>
</UnOrderedList>

<Notes>
  The `initialState` is used only on the first render and is disregraded further
  on. If the initial state is an expensive computation, it could be passed to
  the `useState` as a callback function as well. The `setState` takes in the new
  state and enqueues a re-render.
</Notes>

---

<CodeSurfer theme={themeStyles}>

```js title="Counter"
import React, { useState } from "react";

export const Counter = () => {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  const decerement = () => {
    setCount(count - 1);
  };

  return (
    <>
      <div>{`Counter: ${count}`}</div>
      <div>
        <button onClick={increment}>➕ Increment</button>
        <button onClick={decerement}>➖ Decrement</button>
      </div>
    </>
  );
};
```

</CodeSurfer>

<Overlay columns={2}>
  <CodeSandbox>
    <Counter />
  </CodeSandbox>
</Overlay>

---

<Heading> useEffect </Heading>

```js
useEffect(() => {
  const interval = setIn;

  // cleanup
  return () => {
    subscription.unsubscribe();
  };
});
```

<UnOrderedList>
  <ListItem>
    Used for running imperative code such timers, mutation, subscription,
    logging etc.
  </ListItem>
  <ListItem>Runs after the render cycle is completed.</ListItem>
  <ListItem>Can be run optionally by passing it dependency list.</ListItem>
  <ListItem>
    Returns a cleanup function which runs after the effect, similar to{" "}
    <i>ComponentWillunmount</i>.
  </ListItem>
  <ListItem>
    Similar to <i>ComponentDidUpdate</i> and <i>ComponentWillunmount</i>{" "}
    lifecycle methods in class components.
  </ListItem>
</UnOrderedList>

---

<CodeSurfer>

```js title="Counter"
import React, { useState, useEffect } from "react";

export function Counter() {
  const [count, setCount] = useState(0);
  // Similar to componentDidMount
  // and componentDidUpdate:
  useEffect(() => {
    // Update the document title
    // using the browser API
    document.title = `You clicked ${count} times`;
  });

  increment = () => setCount(count + 1);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={increment}>Click me</button>
    </div>
  );
}
```

</CodeSurfer>

<Overlay columns={2}>
  <CodeSandbox>
    <TitleEffect />
  </CodeSandbox>
</Overlay>

---

<Heading> useRef </Heading>

```js
const refContainer = useRef(initialValue);
```

<UnOrderedList>
  <ListItem>Persists for the full lifetime of the component.</ListItem>
  <ListItem>
    Returns a mutable ref object with a property called <i>current</i>.
  </ListItem>
  <ListItem>
    Takes an initial value and initializes current property of the ref object.
  </ListItem>
  <ListItem>
    It's more than just a way to access the DOM node, it can keep mutable
    variables like instance fields.
  </ListItem>
  <ListItem>Returns same ref on every render.</ListItem>
  <ListItem>
    Doesn't trigger or notify of state changes and component updates.
  </ListItem>
</UnOrderedList>

---

<CodeSurfer theme={themeStyles}>

```jsx title="IntervalRef"
const delay = 1000;

const IntervalRef = ({ setClean, setCount, count }) => {
  useEffect(() => {
    // Starts timer
    setInterval(() => setCount(count + 1), delay);

    return () => {
      clearInterval(intervalIdRef.current);
    };
    //Similar to ComponentDidMount
  }, []);

  return <h1>{count}</h1>;
};
```

```jsx title="IntervalRef Example" 1:17
const delay = 1000;

const IntervalRef = ({ setClean, setCount, count }) => {
  // Interval callback
  const callbackRef = useRef();
  // Interval Id;
  const intervalIdRef = useRef();

  useEffect(() => {
    // Runs after every render and
    // updates the ref with new count
    callbackRef.current = () => setCount(count + 1);
  });

  useEffect(() => {
    // Starts timer and set intervalRef;
    intervalIdRef.current = setInterval(() => callbackRef.current(), delay);

    return () => {
      clearInterval(intervalIdRef.current);
    };
  }, []);
};
```

```jsx title="IntervalRef Example" 1:34
const delay = 1000;

const IntervalRef = ({ setClean, setCount, count }) => {
  // Interval callback
  const callbackRef = useRef();
  // Interval Id;
  const intervalIdRef = useRef();

  useEffect(() => {
    // Runs after every render and updates the ref with new count
    callbackRef.current = () => setCount(count + 1);
  });

  //Similar to ComponentDidMount
  useEffect(() => {
    // Starts setInterval
    intervalIdRef.current = setInterval(() => callbackRef.current(), delay);

    // Similar to ComponentWillunmount
    return () => {
      // Runs cleanup function
      setClean(true);
      clearInterval(intervalIdRef.current);
    };
  }, []);

  return <h1>{count}</h1>;
};
```

</CodeSurfer>

<Overlay columns={2}>
  <CodeSandbox>
    <IntervalRefExample />
  </CodeSandbox>
</Overlay>

---

<Heading>useLayoutEffect</Heading>

```js
useLayoutEffect(() => {
  // Do something

  // cleanup
  return () => {
    // cleanup tasks
  };
});
```

<UnOrderedList>
  <ListItem>
    Signature is identical to <i>useEffect</i> hook.
  </ListItem>
  <ListItem>Fires synchronously after all DOM updates.</ListItem>
  <ListItem>Fires after render but before the paint.</ListItem>
  <ListItem>Use it to read DOM layout and synchronously re-render.</ListItem>
  <ListItem>Blocks visual updates and should be used cautiously.</ListItem>
</UnOrderedList>

---

 <CodeSurfer>

```jsx title=LayoutEffect
export const LayoutEffect = () => {
  const [count, setCount] = React.useState(0);

  useLayoutEffect(() => {
    if (count === 0) setCount(3.14);
  }, [count]);

  return (
    <Card
      title='useLayoutEffect'
      actionButton={
        <button onClick={() => setCount(0)}>
          <span>▶️</span>
        </button>
      }
    >
      <span>🥧</span>
      {` = ${count}`}
    </Card>
  );
};
```

 </CodeSurfer>

<Overlay columns={2}>
  <CodeSandbox>
    <LayoutEffect />
  </CodeSandbox>
</Overlay>

---

<Heading>useEffect vs useLayoutEffect</Heading>
<ImageLink
  src='https://github.com/bansalrachita/react-hooks-slides/blob/master/src/images/uselayouteffect.gif?raw=true'
  width='600px'
  height='250px'
/>

---

<Heading>useContext</Heading>

```js
const value = useContext(MyContext);
```

<UnOrderedList>
  <ListItem>
    Accepts a context object and returns the current context value for that
    context.
  </ListItem>
  <ListItem>
    <i>useContext</i> lets user read the context value and subscribe to its
    changes.
  </ListItem>
  <ListItem>
    Component calling the <i>useContext</i> is always rerendered when the
    context value changes.
  </ListItem>
  <ListItem>
    <i>MyContext.Provider</i> is still needed in the tree to provide the context
    value.
  </ListItem>
</UnOrderedList>

---

<CodeSurfer theme={themeStyles}>

```jsx title="ThemeProvider Context"
const ThemeContext = React.createContext(themes.light);

export const ThemeProvider = () => {
  return (
    <ThemeContext.Provider value={themes.dark}>
      <Toolbar />
    </ThemeContext.Provider>
  );
};

const ThemedButton = () => {
  // Returns the current value of theme context object.
  const theme = useContext(ThemeContext);

  return (
    <button style={{ background: theme.background, color: theme.foreground }}>
      I am styled by theme context!
    </button>
  );
};
```

</CodeSurfer>

<Overlay columns={2}>
  <CodeSandbox>
    <UsingContext />
  </CodeSandbox>
</Overlay>

<Notes>
  The value of the context object is determined by the nearest context provider
  above the component which its called in. The rerender happens even if the
  component is using React.memo or ComponentShouldUpdate and start from the
  component itself.
</Notes>

---

<Heading>useReducer</Heading>

```js
const [state, dispatch] = useReducer(reducer, initialArg, init);
```

<UnOrderedList>
  <ListItem>
    Is an alternative to <i>useState</i>
  </ListItem>
  <ListItem>
    Accepts a reducer of type <i>(state, action) => newState</i>
  </ListItem>
  <ListItem>
    Returns the current <i>state</i> paired with <i>dispatch</i>
  </ListItem>
  <ListItem>Takes in initial state as the second argument</ListItem>
  <ListItem>
    To initialize lazily, a third argument is passed as a function.
  </ListItem>
</UnOrderedList>

<Notes>
  The init function lets you initilize the state outside of the reducer and can
  come in handy for resetting initial state later.
</Notes>

---

<Heading> When to use? </Heading>

<UnOrderedList>
  <ListItem>
    Preferable to <i>useState</i> when the state logic is complex like objects.
  </ListItem>
  <ListItem>When next state depends on the previous one.</ListItem>
  <ListItem>
    For optimizing performance in components that trigger deep updates.
  </ListItem>
</UnOrderedList>

<Notes>
  This can be done by passing down dispatch function directly from `useReducer`
  via context instead passing down callbacks explicitly. Any child in the
  component tree can then use the dispatch to pass actions and update the state
  in the reducer.
</Notes>

---

<CodeSurfer>

```js title="Notes Example"
const NotesApp = () => {
  return (
    <>
      <NotesToolBar>
        <Input />
        <Button>➕ Add</Button>
        <Button>➖ Remove</Button>
      </NotesToolBar>
      <hr />
      <strong>Notes:</strong>
      <List>
        {state.map((note, idx) => (
          <ListItem>{`${idx + 1}. ${note}`}</ListItem>
        ))}
      </List>
    </>
  );
};
```

```js title="Notes Example"
const initialState = ["Hello there 👋!", "Add more notes below."];

export const reducer(state, action) {
  switch (action.type) {
    case "add":
      return [...state, action.note];
    case "remove":
      return state?.slice(0, state?.length - 1);
    default:
      return state;
  }
}

const NotesApp = () => {
  const [state] = useReducer(reducer, initialState);

  return (
    <>
      <NotesToolBar>
        <Input />
        <Button>➕ Add</Button>
        <Button>➖ Remove</Button>
      </NotesToolBar>
      <hr />
      <strong>Notes:</strong>
      <List>
        {state.map((note, idx) => (
          <ListItem>{`${idx + 1}. ${note}`}</ListItem>
        ))}
      </List>
    </>
  );
};
```

```jsx title="Notes Example"
const NotesApp = () => {
  const [state, dispatch] = useReducer(reducer, initialState);
  const noteRef = useRef();

  const onChange = (e) => {
    noteRef.current = e.target.value;
  };

  return (
    <>
      <NotesToolBar>
        <Input onChange={onChange} />
        <Button
          onClick={() => dispatch({ type: "add", note: noteRef.current })}
        >
          ➕ Add
        </Button>
        <Button onClick={() => dispatch({ type: "remove" })}>➖ Remove</Button>
      </NotesToolBar>
      <hr />
      <strong>Notes:</strong>
      <List>
        {state.map((note, idx) => (
          <ListItem>{`${idx + 1}. ${note}`}</ListItem>
        ))}
      </List>
    </>
  );
};
```

```jsx title="Notes Example"
const NotesApp = () => {
  const [state, dispatch] = useReducer(reducer, initialState);
  const noteRef = useRef();

  const onChange = (e) => {
    noteRef.current = e.target.value;
  };

  return (
    <>
      <NotesToolBar>
        <Input onChange={onChange} />
        <Button
          onClick={() => dispatch({ type: "add", note: noteRef.current })}
        >
          ➕ Add
        </Button>
        <Button onClick={() => dispatch({ type: "remove" })}>➖ Remove</Button>
      </NotesToolBar>
      <hr />
      <strong>Notes:</strong>
      <List>
        {state.map((note, idx) => (
          <ListItem>{`${idx + 1}. ${note}`}</ListItem>
        ))}
      </List>
    </>
  );
};
```

</CodeSurfer>

<Overlay columns={2}>
  <CodeSandbox>
    <NotesApp />
  </CodeSandbox>
</Overlay>

---

<Heading>useCallback</Heading>

```js
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

<UnOrderedList>
  <ListItem>
    Takes in an inline callback as an argument and an array of dependencies.
  </ListItem>
  <ListItem>
    Returns a memoized function that only changes when the dependencies update.{" "}
  </ListItem>
  <ListItem>
    Useful when passing callback as props to the child components.
  </ListItem>
  <ListItem>
    <i>useCallback(fn, deps)</i> is equivalent to <i>useMemo(() => fn, deps)</i>
  </ListItem>
</UnOrderedList>

<Notes>
  Child components that rely on referencial equality will only re-render when
  the dependencies have udpated and this will prevent unecessary rerenders.
</Notes>

---

<CodeSurfer>

```jsx title="❌ Wrong usage"
export const Example = () => {
  import React, { useCallback } from "react";

  const onClick = useCallback(() => {
    // Do something...
  }, []);

  // Cost of optimization is more than the optimization
  return <button onClick={onClick}>"I'm just a simple button 👻"</button>;
};
```

```jsx title="🟢 Correct usage"
export const Example = () => {
  import React, { useCallback } from "react";

  const onClick = useCallback(() => {
    // Do something...
  }, []);

  return <HugeList data={data} onClick={onClick}></HugeList>;
};

const HugeList = React.memo(() => {
  // ...
});
```

</CodeSurfer>

---

<Heading>useCallback in action</Heading>
<ImageLink
  src='https://github.com/bansalrachita/react-hooks-slides/blob/master/src/images/useCallback.gif?raw=true'
  width='600px'
  height='250px'
/>

---

<Heading> useMemo </Heading>

```js
const memoizedValue = useMemo(() => expensiveFn(a, b), [a, b]);
```

<UnOrderedList>
  <ListItem>Returns a memoized value.</ListItem>
  <ListItem>
    Like the <i>useCallback</i> hook, it takes in a function as an argument and
    an array of dependencies.
  </ListItem>
  <ListItem>
    It recomputes the value only when one of dependencies is updated.
  </ListItem>
  <ListItem>
    Unlike the <i>useEffect</i> hook, it runs during the render time and not
    after render is completed.
  </ListItem>
  <ListItem>
    If no dependencies are provided, the value is re-computed at every render.
  </ListItem>
  <ListItem>
    Should be relied upon for optimization, not as a sematic guarantee.
  </ListItem>
</UnOrderedList>

<Notes>
  Don't confuse `useMemo` with React's `memo`. React.memo is used to wrap the
  component to prevent re-renders whereas `usMemo` is used to memoize values.
  You might think that why doesn't React apply useMemo to everything by default?
  The reason is that React does a comparison with the dependency list values to
  decide if it should recompute the value. This computation can be more
  expensive than just recomputing the value during re-render.
</Notes>

---

<CodeSurfer>

```js title="SearchResults"
export const SearchResults = ({ data }) => {
  const [inputText, setInputText] = useState("");
  const [searchInput, setSearchInput] = useState("");

  const onChangeInput = (e) => {
    setInputText(e.target.value);
  };

  const searchResults = () =>
    data.filter((d) => {
      console.log("Filter function is running ...");

      const regex = new RegExp(`${searchInput}`, "i");
      return d.search(regex) !== -1;
    });

  const onClick = () => {
    setSearchInput(inputText);
  };

  return (
    <>
      <Input value={inputText} onChange={onChangeInput}></Input>
      <Button onClick={onClick}>Search 🔍</Button>
      <List>
        {searchResults.map((result, index) => (
          <ListItem key={`mt-${index}`}>{result}</ListItem>
        ))}
      </List>
    </>
  );
};
```

```js title="SearchResults"
export const SearchResults = ({ data }) => {
  const [inputText, setInputText] = useState("");
  const [searchInput, setSearchInput] = useState("");

  const onChangeInput = (e) => {
    setInputText(e.target.value);
  };

  const searchResults = useMemo(
    () =>
      data.filter((d) => {
        console.log("Filter function is running ...");

        const regex = new RegExp(`${searchInput}`, "i");
        return d.search(regex) !== -1;
      }),
    [searchInput]
  );

  const onClick = () => {
    setSearchInput(inputText);
  };

  return (
    <>
      <Input value={inputText} onChange={onChangeInput}></Input>
      <Button onClick={onClick}>Search 🔍</Button>
      <List>
        {searchResults.map((result, index) => (
          <ListItem key={`mt-${index}`}>{result}</ListItem>
        ))}
      </List>
    </>
  );
};
```

</CodeSurfer>

<Overlay columns={2}>
  <CodeSandbox>
    <SearchResults data={memoData} />
  </CodeSandbox>
</Overlay>

---

<Heading>useImperativeHandle</Heading>

```js
useImperativeHandle(ref, createHandle, [deps]);
```

<UnOrderedList>
  <ListItem>
    Customizes the instance value that is exposed to the parent components using
    refs.
  </ListItem>
  <ListItem>
    Should be used with <i>forwardRef</i>
  </ListItem>
</UnOrderedList>

---

<CodeSurfer>

```js title="FancyInput"
const FancyInput = React.forwardRef(({ children, ...rest }, ref) => {
  const [focussed, setFocussed] = useState(false);
  const inputRef = useRef();

  // Runs only once.
  useImperativeHandle(
    ref,
    () => {
      return {
        focus: () => {
          // updates the background color on focus
          setFocussed(true);
          inputRef.current.focus();
        },
        blur: () => {
          setFocussed(false);
          inputRef.current.blur();
        },
      };
    },
    []
  );

  return (
    <Input {...rest} ref={inputRef} focussed={focussed}>
      {children}
    </Input>
  );
});
```

```jsx title="FancyInputExample" 1:20
export const FancyInputExample = () => {
  const buttonRef = React.createRef();

  const onClick = () => {
    buttonRef.current.focus();
  };
  const onClickBlur = () => {
    buttonRef.current.blur();
  };

  return (
    <>
      <FancyInput ref={buttonRef}></FancyInput>
      <div>
        <Button onClick={onClick}>Focus me</Button>
        <Button onClick={onClickBlur}>Blur me</Button>
      </div>
    </>
  );
};
```

</CodeSurfer>

<Overlay>
  <div></div>
  <CodeSandbox>
    <FancyInputExample />
  </CodeSandbox>
</Overlay>

---

<Heading>useDebugValue</Heading>

```js
useDebugValue(date, (date) => date.toDateString());
```

<UnOrderedList>
  <ListItem>
    Can be used to display a label for custom hooks in React dev-tools.
  </ListItem>
  <ListItem>
    Accepts a formatting function which is called only when the hook is
    inspected.
  </ListItem>
</UnOrderedList>

---

<CodeSurfer>

```jsx title="useFriendStatus"
function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  // ...

  // Show a label in DevTools next to this Hook
  // e.g. "FriendStatus: Online"
  useDebugValue(isOnline ? "Online" : "Offline");

  return isOnline;
}
```

</CodeSurfer>

---

<Heading>Do hooks replace redux?</Heading>

---

<Heading>TLDR; Not really</Heading>
<UnOrderedList>
  <ListItem>Hooks are an aternative to class based react components</ListItem>
  <ListItem>Should be used for component state management</ListItem>
  <ListItem>
    Redux stores and manages the application state (travel-debugging, data
    persistance)
  </ListItem>
</UnOrderedList>

---

<Layout>
  <Heading marginTop='auto'>Thank you!</Heading>
</Layout>

---

<Layout>
  <UnOrderedList listStyle='none'>
    <ListItem>
      <AnchorLink
        widthSize='large'
        href='https://www.linkedin.com/in/rachitabansal/'
      >
        <ImageLink
          height='28px'
          src='https://img.shields.io/badge/linkedin-%230077B5.svg?&style=for-the-badge&logo=linkedin&logoColor=white'
        />
        @rachitabansal
      </AnchorLink>
    </ListItem>
    <ListItem>
      <AnchorLink
        height='28px'
        widthSize='large'
        href='https://twitter.com/rachitaabansal'
      >
        <ImageLink
          height='28px'
          src='https://img.shields.io/badge/twitter-%231DA1F2.svg?&style=for-the-badge&logo=twitter&logoColor=white'
        />
        @rachitabansal
      </AnchorLink>
    </ListItem>
    <ListItem>
      <AnchorLink widthSize='large' href='https://medium.com/@rachitabansal'>
        <ImageLink
          height='28px'
          src='https://img.shields.io/badge/medium-%2312100E.svg?&style=for-the-badge&logo=medium&logoColor=white'
        />
        @rachitabansal
      </AnchorLink>
    </ListItem>
    <ListItem>
      <AnchorLink
        widthSize='large'
        href='https://github.com/react-hooks-slides'
      >
        <ImageLink
          height='40px'
          width='40px'
          src='https://github.com/bansalrachita/react-hooks-slides/blob/master/src/images/github.svg?raw=true'
        />
        @bansalrachita
      </AnchorLink>
    </ListItem>
  </UnOrderedList>
</Layout>

---

<Heading>Talk stack & references </Heading>
<UnOrderedList>
  <ListItem>mdx-deck@4.x</ListItem>
  <ListItem>code-surfer@3.x</ListItem>
  <ListItem>styled-components@5.x</ListItem>
  <ListItem>https://reactjs.org/</ListItem>
  <ListItem>
    <span>{`Find the slides @`}</span>
    <AnchorLink
      size='medium'
      href='https://bansalrachita.github.io/react-hooks-slides/'
    >
      https://bansalrachita.github.io/react-hooks-slides/
    </AnchorLink>
  </ListItem>
</UnOrderedList>
