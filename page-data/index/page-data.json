{"componentChunkName":"component---node-modules-gatsby-theme-mdx-deck-src-templates-deck-js","path":"/","matchPath":"/*","result":{"data":{"deck":{"id":"a6d22f7c-00bf-525b-960e-764b4974f61b","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar theme = _objectSpread(_objectSpread(_objectSpread({}, themes.future), themes.prism), nightOwl);\n\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Notes = makeShortcode(\"Notes\");\nvar layoutProps = {\n  theme: theme,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(Layout, {\n    mdxType: \"Layout\"\n  }, mdx(Split, {\n    mdxType: \"Split\"\n  }, mdx(Split, {\n    mdxType: \"Split\"\n  }, mdx(ImageLink, {\n    shape: \"round\",\n    src: \"https://raw.githubusercontent.com/bansalrachita/react-hooks-slides/fe2daa3af58e856a8c3433abf79412c62cfbf622/src/images/react-logo.svg\",\n    width: \"100px\",\n    height: \"100px\",\n    alt: \"React hooks logo\",\n    mdxType: \"ImageLink\"\n  }), mdx(Heading, {\n    mdxType: \"Heading\"\n  }, \"Introduction\"), mdx(Heading, {\n    mdxType: \"Heading\"\n  }, \"to React hooks\"))), mdx(Steps, {\n    mdxType: \"Steps\"\n  }, mdx(ImageLink, {\n    margin: \"60px 0 0 50px\",\n    shape: \"round\",\n    src: \"https://github.com/bansalrachita/react-hooks-slides/blob/master/src/images/hook.gif?raw=true\",\n    width: \"300px\",\n    height: \"300px\",\n    alt: \"Gif of Captain Hook\",\n    mdxType: \"ImageLink\"\n  }))), mdx(\"hr\", null), mdx(Heading, {\n    mdxType: \"Heading\"\n  }, \" What is React? \"), mdx(Quote, {\n    mdxType: \"Quote\"\n  }, \"\\\"Declarative, efficient and flexible JavaScript library for building user interfaces. It lets you compose complex UIs from smaller and isolated pieces of code called \\\"components\\\"\"), mdx(\"a\", {\n    href: \"https://reactjs.org/\"\n  }, \"- https://reactjs.org/\"), mdx(\"hr\", null), mdx(Heading, {\n    mdxType: \"Heading\"\n  }, \" React hooks \"), mdx(Grid, {\n    columns: 2,\n    mdxType: \"Grid\"\n  }, mdx(Steps, {\n    mdxType: \"Steps\"\n  }, mdx(\"p\", null, mdx(\"code\", null, \"useCake()\")), mdx(\"p\", null, mdx(\"code\", null, \"useFrosting()\")), mdx(\"p\", null, mdx(\"code\", null, \"useBake()\")), mdx(\"p\", null, mdx(\"code\", null, \"usePastries()\")))), mdx(\"hr\", null), mdx(Overlay, {\n    colums: 12,\n    mdxType: \"Overlay\"\n  }, \"\\u27A1\"), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"title=\\\"React < 16.8\\\" 3:10,14,17,20,26:29\",\n    \"title\": \"\\\"React\",\n    \"<\": true,\n    \"16.8\\\"\": true,\n    \"3:10,14,17,20,26:29\": true\n  }, \"import React from \\\"react\\\";\\n\\nclass Counter extends React.Component {\\n  constructor(props) {\\n    super(props);\\n\\n    this.state = {\\n      count: 0,\\n    };\\n  }\\n\\n  handleClick = () => {\\n    const { count } = this.state;\\n    this.setState({ count: count + 1 });\\n  };\\n\\n  render() {\\n    const { count } = this.state;\\n\\n    return (\\n      <>\\n        <div>{`Count: ${count}`}</div>\\n        <button onClick={this.handleClick}>+</button>\\n      </>\\n    );\\n  }\\n}\\n\\nexport default Counter;\\n\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"title=After\",\n    \"title\": \"After\"\n  }, \"import React, { useCallback, useState } from \\\"react\\\";\\n\\nexport const Counter = () => {\\n  const [count, setCount] = useState(0);\\n\\n  const onClickIncrement = useCallback(() => {\\n    setCount(count + 1);\\n  }, [count]);\\n\\n  const onClickDecrement = useCallback(() => {\\n    setCount(count - 1);\\n  }, [count]);\\n\\n  return (\\n    <>\\n      <div>{`Count: ${count}`}</div>\\n      <div>\\n        <button onClick={onClickDecrement}>-</button>\\n        <button onClick={onClickIncrement}>+</button>\\n      </div>\\n    </>\\n  );\\n};\\n\"))), mdx(\"hr\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Uses function instead of a class\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Simplified by reducing template code\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Separation of concerns\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"No render function and lifecycle methods\")), mdx(\"hr\", null), mdx(\"h1\", null, \"Rules of hooks\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Only call hooks at the top level\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Only call Hooks from react function components or custom hooks.\")), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"- Only Call Hooks at the Top Level Don't call hooks inside of loops, nested functions or inside conditions. This ensures that hooks are always called in the same order in successive component renders. The way this works is React stores the sequence of hooks call during the first render and keeps checking against the order hooks are called in subsequent renders of the component. - Only Call Hooks from React Functions.Ensure that state logic is available to components source code.\"), mdx(\"hr\", null), mdx(CodeSurfer, {\n    theme: vsDark,\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"import React from \\\"react\\\";\\n\\nconst useQuery = () => {};\\n\\nexport const Example = ({ data }) => {\\n  // success\\n  useQuery();\\n\\n  // Error\\n  if (!data) {\\n    useEffect(() => {\\n      useQuery();\\n    });\\n  }\\n\\n  // Error\\n  onClick = () => useQuery();\\n\\n  return (\\n    <>\\n      <button onClick={onClick}>Refresh</button>\\n      {data?.map((d) => d.title)}\\n    </>\\n  );\\n};\\n\"))), mdx(\"hr\", null), mdx(\"h1\", null, \"Built-in hooks\"), mdx(ImageLink, {\n    src: \"https://github.com/bansalrachita/react-hooks-slides/blob/master/src/images/hooks_api.png?raw=true\",\n    width: \"500px\",\n    height: \"700px\",\n    altText: \"list of built-in hooks\",\n    mdxType: \"ImageLink\"\n  }), mdx(\"hr\", null), mdx(\"h1\", null, \"useState\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const [state, setState] = useState(initialState);\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Return a stateful value and a function to replace it.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Takes in an initial state.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"setState takes in the new state and enqueues a re-render.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Unlike \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"setState\"), \" useState doesn't merge objects.\")), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"The `initialState` is used only on the first render and is disregraded further on. If the initial state is an expensive computation, it could be passed to the `useState` as a callback function as well.\"), mdx(\"hr\", null), mdx(Split, {\n    mdxType: \"Split\"\n  }, mdx(CodeSurfer, {\n    theme: vsDark,\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"title=Counter\",\n    \"title\": \"Counter\"\n  }, \"import React, { useCallback, useState } from \\\"react\\\";\\n\\nconst Counter = () => {\\n  const [count, setCount] = useState(0);\\n\\n  const onClickIncrement = useCallback(() => {\\n    setCount(count + 1);\\n  }, [count]);\\n\\n  const onClickDecrement = useCallback(() => {\\n    setCount(count - 1);\\n  }, [count]);\\n\\n  return (\\n    <>\\n      <div>{`Counter: ${count}`}</div>\\n      <div>\\n        <button onClick={onClickDecrement}>-</button>\\n        <button onClick={onClickIncrement}>+</button>\\n      </div>\\n    </>\\n  );\\n};\\n\\nexport default Counter;\\n\"))), mdx(Counter, {\n    mdxType: \"Counter\"\n  })), mdx(\"hr\", null), mdx(\"h1\", null, \"useEffect\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"useEffect(() => {\\n  const interval = setIn;\\n\\n  // cleanup\\n  return () => {\\n    subscription.unsubscribe();\\n  };\\n});\\n\")), mdx(\"hr\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Used for running imperative code such timers, mutation, subscription, logging etc.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Runs after the render complete render cycle.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Can be run optionally by passing it dependency list.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Returns a cleanup function which run just before the component is unmounted.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Same as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ComponentDidUpdate\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ComponentWillunmount\"), \" lifecycle methods in classes.\")), mdx(\"hr\", null), mdx(Split, {\n    mdxType: \"Split\"\n  }, mdx(CodeSurfer, {\n    theme: vsDark,\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"title=Example\",\n    \"title\": \"Example\"\n  }, \"import React, { useState, useEffect } from \\\"react\\\";\\n\\nexport function Example() {\\n  const [count, setCount] = useState(0);\\n  // Similar to componentDidMount and componentDidUpdate:\\n  useEffect(() => {\\n    // Update the document title using the browser API\\n    document.title = `You clicked ${count} times`;\\n  });\\n\\n  return (\\n    <div>\\n      <p>You clicked {count} times</p>\\n      <button onClick={() => setCount(count + 1)}>Click me</button>\\n    </div>\\n  );\\n}\\n\"))), mdx(TitleEffect, {\n    mdxType: \"TitleEffect\"\n  })), mdx(\"hr\", null), mdx(\"h1\", null, \"useRef\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const refContainer = useRef(initialValue);\\n\")), mdx(\"hr\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Persists for the full lifetime of the component.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Returns a mutable ref object with a property called \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"current\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Takes in an initial value and initializes current property of the ref object.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It's more than just a way to access the DOM node, it can keep mutable variables like instance fields.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Returns same ref on every render.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Doesn't trigger or notify of state changes and component updates.\")), mdx(\"hr\", null), mdx(Split, {\n    mdxType: \"Split\"\n  }, mdx(CodeSurfer, {\n    theme: vsDark,\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"title=IntervalRef\",\n    \"title\": \"IntervalRef\"\n  }, \"const delay = 1000;\\n\\nconst IntervalRef = ({ setClean, setCount, count }) => {\\n  const callbackRef = useRef();\\n  // Stores the interval Id;\\n  const intervalIdRef = useRef();\\n\\n  useEffect(() => {\\n    // Runs after every render and updates the ref with new count\\n    callbackRef.current = () => setCount(count + 1);\\n\\n    // Starts setInterval\\n    if (count === 0) {\\n      intervalIdRef.current = setInterval(() => callbackRef.current(), delay);\\n    }\\n  }, [count]);\\n\\n  //Similar to ComponnentDidMount\\n  useEffect(() => {\\n    // Similar to ComponentWillunmount\\n    return () => {\\n      // Runs cleanup function\\n      setClean(true);\\n      clearInterval(intervalIdRef.current);\\n    };\\n  }, []);\\n\\n  return (\\n    <div>\\n      <h1>{count}</h1>\\n    </div>\\n  );\\n};\\n\"))), mdx(Example, {\n    mdxType: \"Example\"\n  })), mdx(\"hr\", null), mdx(\"h1\", null, \"useLayoutEffect\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"useLayoutEffect(() => {\\n  // Do something\\n\\n  // cleanup\\n  return () => {\\n    // cleanup tasks\\n  };\\n});\\n\")), mdx(\"hr\", null), mdx(ImageLink, {\n    src: \"https://github.com/bansalrachita/react-hooks-slides/blob/master/src/images/uselayouteffect.gif?raw=true\",\n    width: \"600px\",\n    height: \"250px\",\n    mdxType: \"ImageLink\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Signature identical to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useEffect\"), \" hook\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Fires synchronously after all DOM updates\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Fires after render but before the paint\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use it to read DOM layout and synchronously re-render\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Blocks visual updates and should be used cautiously\")), mdx(\"hr\", null), mdx(Split, {\n    mdxType: \"Split\"\n  }, mdx(CodeSurfer, {\n    theme: vsDark,\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"title=LayoutEffect\",\n    \"title\": \"LayoutEffect\"\n  }, \"export const LayoutEffect = () => {\\n  const [count, setCount] = React.useState(0);\\n\\n  React.useLayoutEffect(() => {\\n    if (count === 0) setCount(3.14);\\n  }, [count]);\\n\\n  return (\\n    <Card\\n      title='useLayoutEffect'\\n      actionButton={\\n        <button onClick={() => setCount(0)}>\\n          <span role='img'>\\u25B6\\uFE0F</span>\\n        </button>\\n      }\\n    >\\n      <span role='img'>\\uD83E\\uDD67</span>\\n      {` = ${count}`}\\n    </Card>\\n  );\\n};\\n\"))), mdx(LayoutEffect, {\n    mdxType: \"LayoutEffect\"\n  })), mdx(\"hr\", null), mdx(UseLayoutEffect, {\n    mdxType: \"UseLayoutEffect\"\n  }), mdx(\"hr\", null), mdx(\"h1\", null, \"useContext\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const value = useContext(MyContext);\\n\")), mdx(\"hr\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Accepts a context object.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Returns the current context value for that context.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Component calling the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useContext\"), \" is always rerender when the context value changes.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useContext\"), \" lets user read the context value and subscribe to its changes.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<MyContext.Provider>\"), \" is still needed in the tree to provide the context value.\")), mdx(\"hr\", null), mdx(Split, {\n    mdxType: \"Split\"\n  }, mdx(CodeSurfer, {\n    theme: vsDark,\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"title=UsingContext\",\n    \"title\": \"UsingContext\"\n  }, \"const ThemeContext = React.createContext(themes.light);\\n\\nexport const UsingContext = () => {\\n  return (\\n    <ThemeContext.Provider value={themes.dark}>\\n      <Toolbar />\\n    </ThemeContext.Provider>\\n  );\\n};\\n\\nconst ThemedButton = () => {\\n  const theme = useContext(ThemeContext);\\n\\n  return (\\n    <button style={{ background: theme.background, color: theme.foreground }}>\\n      I am styled by theme context!\\n    </button>\\n  );\\n};\\n\"))), mdx(UsingContext, {\n    mdxType: \"UsingContext\"\n  })), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"The value of the context object is determined by the nearest context provider above the component which its called in. The rerender happens even if the component is using React.memo or ComponentShouldUpdate and start from the component itself.\"), mdx(\"hr\", null), mdx(\"h1\", null, \"useReducer\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const [state, dispatch] = useReducer(reducer, initialArg, init);\\n\")), mdx(\"hr\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Is an alternative to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useState\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Accepts a reducer of type \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"(state, action) => newState\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Returns the current \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"state\"), \" paired with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"dispatch\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Takes in initial state as the second argument\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"To initialize lazily, a third argument is passed as a function.\")), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"The init function lets you initilize the state outside of the reducer and can come in handy for resetting initial state later.\"), mdx(\"h2\", null, \"When to use?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Preferable to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useState\"), \" when the state logic is complex like objects.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When next state depends on the previous one.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For potimizing performance in component that trigger deep updates.\")), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"This can be done by passing down dispatch function directly from `useReducer` via context instead passing down callbacks explicitly. Any child in the component tree can then use the dispatch to pass actions and update the state in the reducer.\"), mdx(\"hr\", null), mdx(Split, {\n    mdxType: \"Split\"\n  }, mdx(CodeSurfer, {\n    theme: vsDark,\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"title=NotesApp\",\n    \"title\": \"NotesApp\"\n  }, \"\\nconst reducer(state, action) {\\n  switch (action.type) {\\n    case \\\"add\\\":\\n      return [...state, action.note];\\n    case \\\"remove\\\":\\n      return state?.slice(0, state?.length - 1);\\n    default:\\n      return state;\\n  }\\n}\\n\\nconst NotesApp = () => {\\n  const [state, dispatch] = useReducer(reducer, initialState);\\n  const noteRef = useRef();\\n\\n  const onChange = (e) => {\\n    noteRef.current = e.target.value;\\n  };\\n\\n  return (\\n    <>\\n      <NotesToolBar>\\n        <Input onChange={onChange} />\\n        <Button\\n          onClick={() => dispatch({ type: \\\"add\\\", note: noteRef.current })}\\n        >\\n          \\u2795 Add\\n        </Button>\\n        <Button onClick={() => dispatch({ type: \\\"remove\\\" })}>\\u2796 Remove</Button>\\n      </NotesToolBar>\\n      <hr />\\n      <strong>Notes:</strong>\\n      <List>\\n        {state.map((note, idx) => (\\n          <ListItem>{`${idx + 1}. ${note}`}</ListItem>\\n        ))}\\n      </List>\\n    </>\\n  );\\n};\\n\\n\"))), mdx(NotesApp, {\n    mdxType: \"NotesApp\"\n  })), mdx(\"hr\", null), mdx(\"h1\", null, \"useCallback\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const memoizedCallback = useCallback(() => {\\n  doSomething(a, b);\\n}, [a, b]);\\n\")), mdx(\"hr\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Takes in an inline callback as an argument and an array of dependencies.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Returns a memoized function that only changes when the dependencies update.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Useful when passing callback as props to the child components.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useCallback(fn, deps)\"), \" is equivalent to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useMemo(() => fn, deps)\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"Child components that rely on referencial equality will only re-render when the dependencies have udpated and this will prevent unecessary rerenders.\"), mdx(\"hr\", null), mdx(\"h1\", null, \"useMemo\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\\n\")), mdx(\"hr\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Returns a memoized value.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Like \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useCallback\"), \", it takes in a function as an argument and an array of dependencies.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Only recomputes the value when one of dependencies have updated.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Unlike \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useEffect\"), \", it runs during render time instead of after rendering.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If no dependencies are provided, value is computed every render.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Should be relied upon for optimization, not as a sematic guarantee.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Write code that works without \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useMemo\"), \" and later optimize for performance.\")), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"Don't confuse `useMemo` with React's `memo`. React.memo is used to wrap the component to prevent re-renders whereas `usMemo` is used to memoize values. You might think that why doesn't React apply useMemo to everything by default? The reason is that React does a comparison with the dependency list values to decide if it should recompute the value. This computation can be more expensive than just recomputing the value during re-render.\"), mdx(\"hr\", null), mdx(Split, {\n    mdxType: \"Split\"\n  }, mdx(CodeSurfer, {\n    theme: vsDark,\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"title=\\\"Title\\\"\",\n    \"title\": \"\\\"Title\\\"\"\n  }, \"export const ListMemo = ({ data }) => {\\n  const [inputText, setInputText] = useState(\\\"\\\");\\n  const [searchInput, setSearchInput] = useState(\\\"\\\");\\n\\n  const onChangeInput = (e) => {\\n    setInputText(e.target.value);\\n  };\\n\\n  const searchResults = useMemo(\\n    () =>\\n      data.filter((d) => {\\n        const regex = new RegExp(`${searchInput}`, \\\"i\\\");\\n        console.log(\\\"Filter function is running ...\\\");\\n        return d.search(regex) !== -1;\\n      }),\\n    [searchInput]\\n  );\\n\\n  const onClick = () => {\\n    setSearchInput(inputText);\\n  };\\n\\n  return (\\n    <>\\n      <input value={inputText} onChange={onChangeInput}></input>\\n      <Button onClick={onClick}>Search \\uD83D\\uDD0D</Button>\\n      <hr />\\n      <List>\\n        {searchResults.map((result, index) => (\\n          <ListItem key={`mt-${index}`}>{result}</ListItem>\\n        ))}\\n      </List>\\n    </>\\n  );\\n};\\n\"))), mdx(ListMemo, {\n    data: memoData,\n    mdxType: \"ListMemo\"\n  })), mdx(\"hr\", null), mdx(\"h1\", null, \"useImperativeHandle\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"useImperativeHandle(ref, createHandle, [deps]);\\n\")), mdx(\"hr\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Customizes the instance value that is exposed to the parent components using refs.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Should be used with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"forwardRef\"))), mdx(\"hr\", null), mdx(Split, {\n    mdxType: \"Split\"\n  }, mdx(CodeSurfer, {\n    theme: vsDark,\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"title=\\\"FancyInput\\\"\",\n    \"title\": \"\\\"FancyInput\\\"\"\n  }, \"const FancyInput = React.forwardRef(({ children, ...rest }, ref) => {\\n  const [focussed, setFocussed] = useState(false);\\n  const inputRef = useRef();\\n\\n  // Runs only once.\\n  useImperativeHandle(\\n    ref,\\n    () => {\\n      return {\\n        focus: () => {\\n          // updates the background color on focus\\n          setFocussed(true);\\n          inputRef.current.focus();\\n        },\\n        blur: () => {\\n          setFocussed(false);\\n          inputRef.current.blur();\\n        },\\n      };\\n    },\\n    []\\n  );\\n\\n  return (\\n    <Input {...rest} ref={inputRef} focussed={focussed}>\\n      {children}\\n    </Input>\\n  );\\n});\\n\"))), mdx(FancyInputExample, {\n    mdxType: \"FancyInputExample\"\n  })), mdx(\"hr\", null), mdx(\"h1\", null, \"useDebugValue\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"useDebugValue(value);\\n\")), mdx(\"hr\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Can be used to display a label for custom hooks in React devtools.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Accepts a formatting function which is called only when the hook is inspected.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"useDebugValue(date, (date) => date.toDateString());\\n\")), mdx(\"hr\", null), mdx(\"h1\", null, \"Create your own custom hook!\"), mdx(\"hr\", null), mdx(\"hr\", null), mdx(\"h1\", null, \"Do hooks replace redux?\"), mdx(\"hr\", null), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TLDR; Not really\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Hooks are an aternative to class based react components\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Should be used for component state management\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Redux stores and manages the application state (travel-debugging, data persistance)\")), mdx(\"hr\", null), mdx(\"h1\", null, \"Thank you!\"), mdx(Layout, {\n    mdxType: \"Layout\"\n  }), mdx(\"hr\", null), mdx(\"h2\", null, \"twitter: @rachitabansal\"), mdx(\"h2\", null, \"github: @bansalrachita\"), mdx(\"h3\", null, \"slides: github.com/react-hooks-snippets\"), mdx(Layout, {\n    mdxType: \"Layout\"\n  }), mdx(\"hr\", null), mdx(\"h1\", null, \"Talk stack & references\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"mailto:mdx-deck@4.x\"\n  }, \"mdx-deck@4.x\"), \" + \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"mailto:code-surfer@3.x\"\n  }, \"code-surfer@3.x\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"mailto:styled-components@5.x\"\n  }, \"styled-components@5.x\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://reactjs.org/\"\n  }, \"https://reactjs.org/\"))));\n}\n;\nMDXContent.isMDXComponent = true;","title":"Rules of hooks"}},"pageContext":{"matchPath":"/*","id":"a6d22f7c-00bf-525b-960e-764b4974f61b","slug":"/react-hooks-slides","title":"Rules of hooks"}},"staticQueryHashes":[]}